# -*- coding: utf-8 -*-
"""Env._0- Datos + EDA Predicción de la pérdida de clientes bancarios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M1lqHtNfYDXLTSj7hKdnb3CjdM2pck0H

## **Reto Data Science (DS) y Machine Learning (ML): Proyecto**

- Semana 1: Problema y Datos.
- Semana 2: EDA

# Indice proyecto:
* **0- Datos + EDA Predicción de la pérdida de clientes bancarios**
  * Link: https://colab.research.google.com/drive/1M1lqHtNfYDXLTSj7hKdnb3CjdM2pck0H?usp=sharing

* **1-Limpieza Datos y Feature Predicción de la pérdida de clientes bancarios**
    * Link: https://colab.research.google.com/drive/1dTC_eyjF5PaKuscDm15Rn5AwSfxWqXzf?usp=sharing
    
**Nota**: Al inicio del proyecto se  guardo el archivo original con nombre *Churn_Modelling_Original.csv* en local y se continúa trabajando con la copia del archivo llamada *Seg_Clientes.csv.*

## **Semana 1: Enmarcar el problema y Obtener los datos**

**Proyecto Elegido:** Predicción pérdida de clientes bancarios

**1. Enmarcar el problema**

**1.1 Definir el objetivo en términos de negocio**
El objetivo del proyecto es predecir qué clientes bancarios tienen mayor probabilidad de abandonar el banco . Esto permitirá al banco tomar acciones preventivas, como ofrecer incentivos, mejorar la experiencia del cliente y personalizar estrategias de retención.

**1.2 ¿Cómo se utilizará la solución?**
Segmentación de clientes: Clasificar clientes en propensos a irse vs. propensos a quedarse.

**1.3 ¿Es supervisado o no supervisado?**
Es un problema de aprendizaje supervisado ya que se tiene una variable objetivo definida:

- **Variable a predecir**: Cliente que se fue y Cliente que continua en activo.

El modelo se entrenara con datos históricos de clientes.

**2 Obtener los datos:**

**2.1 Encontrar y documentar la fuente de datos**

Los datos utilizados para el proyecto se han descargado desde Kaggle. Al ser una fuente publica no es necesario solicitar autorización para su uso.

Direccion Web archivo:https://www.kaggle.com/datasets/shubhammeshram579/bank-customer-churn-prediction

Se  guarda da el archivo original con nombre *Churn_Modelling_Original.csv* en local y se trabajara con la copia del archivo llamada *Seg_Clientes.csv.*
"""

#@title **Importar librerias de python.**

# Importar diferentes librerías de Python para manipular y visualizar los datos
import pandas as pd  # Procesar, analizar y limpiar datos
import numpy as np  # Operaciones matemáticas y manipulación de matrices
import seaborn as sns  # Visualización de datos con gráficos estadísticos
import matplotlib.pyplot as plt  # Generación de gráficos y visualización de datos

# Instalar y cargar la librería para generar EDA automático (Exploratory Data Analysis)
!pip install ydata-profiling
from ydata_profiling import ProfileReport  # Creación automática de reportes de análisis de datos

#@title **Cargar datos:**
#Crear DataFrame desde csvy usar comando para leer el CSV descargado y guardado en el Colab.

df_Seg_Clientes = pd.read_csv("Seg_Clientes.csv")

"""##**Explorar los datos para obtener información (Análisis de datos no grafico)**

Para empezar que tipos de datos contiene el archivo a analizar, se realizaran unas visualizaciones en forma tabla para ver su contenido, asi como sí hay valores nulos, etc.

## Visualización de tabla (head - tail):
"""

# Con la función head se muestra las 5 primeras filas del archivo.
df_Seg_Clientes.head()

# Muestra las últimas 5 filas del archivo
df_Seg_Clientes.tail()

"""# **Leyenda Dataframe:**

1. **RowNumber**: Número de fila del cliente.
2. **Customer ID**: identificador único para cada cliente
3. **Surname:** apellido del cliente
4. **Credit Score:** valor numérico que representa la puntuación crediticia del cliente.
5. **Geography:** El país donde reside el cliente (Francia, España o Alemania)
6. **Gender:** El género del cliente (masculino o femenino) (Male or Female)
7. **Age**: La edad del cliente.
8. **Tenure**: El número de años que el cliente ha estado en el banco.
9. **Balance:** El saldo de la cuenta del cliente
10. **NumOfProducts:** La cantidad de productos bancarios que utiliza el cliente (por ejemplo, cuenta de ahorros, tarjeta de crédito)
11. **HasCrCard:** Si el cliente tiene una tarjeta de crédito (1 = sí, 0 = no)
12. **IsActiveMember:** si el cliente es un miembro activo (1 = sí, 0 = no)
13. **EstimatedSalary**: El salario estimado del cliente.
14. **Exited:** si el cliente se ha ido (1 = sí, 0 = no)
"""

#title Valores unicos columna CustomerID
#Este código cuenta el número de valores únicos en la columna "CustomerId".

len(df_Seg_Clientes['CustomerId'].unique()) # solo si hay columna id

#@title **Resumen valores duplicados**
# Verificar si hay filas duplicadas aqui haria igual con duplicated suma True
duplicated_rows = df_Seg_Clientes.duplicated()
num_duplicated_rows = duplicated_rows.sum()
print(f'Número de filas duplicadas: {num_duplicated_rows}')

#@title **Tabla con valores duplicados**
# Identificar y mostrar duplicados
duplicados = df_Seg_Clientes[df_Seg_Clientes.duplicated()]
print(duplicados)

"""#**Resumen valores nulos**

Según el resumen de valores nulos habría un total de 4 nulos repartidos en area geográfica, edad, tarjeta de credito y si esta en activo o no.
A la hora de manipular los datos tendré que tener en cuenta estos nulos para ver si los elimino o los mantego en el estudio.
"""

# Comprobar valores nulos True o False con el .sum te hara la suma del True, es decir sumara 1
#sacara la suma de los nulos
print(df_Seg_Clientes.isnull().sum())

"""#**Tabla con los registros nulos**
Para poder decirdir si eliminar los registros o asignarle algún valor, miro a que lineas afectan y si perntece a alguno de las filas duplicadas.
"""

print(df_Seg_Clientes[df_Seg_Clientes[['Geography', 'Age', 'HasCrCard', 'IsActiveMember']].isnull().any(axis=1)])

"""##**Resumen estadistico(describe)**

 El comando describe() de Pandas proporciona estadísticas descriptivas de las columnas numéricas de un DataFrame.
"""

# resumen estadístico con describe
df_Seg_Clientes.describe()

"""#**Variable categorica**"""

# variables categóricos, si no le indicas la columna sacara todas
#df_Seg_Clientes.value_counts()

#Variable categorica por sexo.
df_Seg_Clientes['Gender'].value_counts()

"""##**Resumen de columnas (info)**

A continuación comprobaré de que tipo es cada columna para poder ver si más adelante es necesario hacer algún cambio o eliminar algún valor que no sea relevante para el estudio.
"""

# resumen columnas con el comando info
df_Seg_Clientes.info()

"""###**Conclusion del conjunto de datos:**

- El archivo contiene *10.002 filas y 14 columnas* con lo que es una muestra adecuada para el análisis.

- Hay variables numericas y de texto, tendré que tenerlo en cuanta por sí más adelante hay que modificar o eliminar alguna columna para el análisis. Asi como los valores nulos que hay en alguna columna (Total Valores nulos:4).

- Número de filas duplicadas: 2 (habrá que eliminarlas)

- Categóricas binarias (Sí= 1 - No=0):
  - **HasCrCard:** Si el cliente tiene una tarjeta de crédito (Sí= 1 - No=0).
  - **IsActiveMember:** si el cliente es un miembro activo ((Sí= 1 - No=0).
  - **Exited:** si el cliente se ha ido (Sí= 1 - No=0).

- Las categorías de **Geography, Gender** se podrían clasificar de la siguiente forma:

  - **Geography:** Es una categórica multinomial porque tiene múltiples valores distintos (Francia, España o Alemania).Requiere codificación para que el modelo pueda interpretarla.
  - **Gender:** Aunque técnicamente tiene dos valores posibles (Male o Female), se considera categórica binaria, pero en formato textual. Necesitaría ser codificada (por ejemplo, Male = 0, Female = 1) para que un modelo pueda interpretarla.

- **Numéricas discretas**
  - **Tenure**: Número de años como cliente. Valores enteros limitados (Min. 0 Max. 10).
  - **NumOfProducts:** Es una variable numérica discreta porque no puede tomar valores decimales,  y esta representada por un número entero de productos (Min.1 - Max. 4).

## **Semana 2: Análisis Exploratorio de Datos (EDA- Exploraty Data Analys)**

A continuación se realizaran diferentes visualizaciones del dataframe en formato gráfico para poder analizar los datos para poder tomar decisiones de cara la modelo de ML y DL.

#**Análisis de datos - Gráfico**

#**Histogramas para variables numéricas**

Se genera histograma de las variables numéricas excluyendo las dos primeras filas (RowNumber y CustomerId no aparecerán en los histogramas) ya que para el estudio inicial no serían necesarias.
"""

# Selecciona las columnas numéricas
num_columns = df_Seg_Clientes.select_dtypes(include=['int64', 'float64']).columns #Filtra las columnas que son de tipo int64 o float64
num_columns = num_columns[2:]  # Excluye las dos primeras columnas

# Crea una figura de tamaño grande
plt.figure(figsize=(16, 20)) #Esto evita que los gráficos se vean amontonados.

# Itera sobre cada columna numérica y genera un histograma
for i, col in enumerate(num_columns, 1):
    plt.subplot(5, 3, i)  # Organiza en una cuadrícula de 5 filas y 3 columnas
    sns.histplot(df_Seg_Clientes[col].dropna(), kde=True)  # Crea el histograma con KDE
    plt.title(f'Distribución de {col}')  # Título con el nombre de la variable
    plt.xlabel(col)
    plt.ylabel('Frecuencia')

# Ajusta el diseño para evitar que los gráficos se solapen
plt.tight_layout() #Esto optimiza el espacio entre los gráficos para que se vean bien organizados.
plt.show() #Muestra los histogramas

"""Los gráficos muestran la distribución de las variables numéricas en el dataset.

Voy a analizar algunos aspectos clave:

**Distribución Normal (Campana de Gauss):**

* 4.	**Credit Score:** valor numérico que representa la puntuación crediticia del cliente.

  * La variable **CreditScore** tiene una forma de campana, lo que indica que la mayoría de los clientes tienen un puntaje crediticio en el centro del rango, con menos clientes en los extremos (muy bajo o muy alto).

* 13.	**EstimatedSalary:** El salario estimado del cliente.

  * **EstimatedSalary** parece seguir una distribución uniforme, lo que sugiere que los salarios están distribuidos de manera equitativa en el rango disponible.

**Sesgos en la Distribución:**

* 7.	**Age:** La edad del cliente.
  * **Age** tiene una concentración de clientes jóvenes, pero hay una disminución progresiva en edades mayores.

* 9.	**Balance:** El saldo de la cuenta del cliente.

  * **Balance** muestra un pico en cero, lo que indica que muchos clientes tienen saldo cero en sus cuentas.

**Variables Categóricas Binarias, Numéricas Discretas,:**
* 10.	**NumOfProducts:** La cantidad de productos bancarios que utiliza el cliente (por ejemplo, cuenta de ahorros, tarjeta de crédito)
* 11.	**HasCrCard:** Si el cliente tiene una tarjeta de crédito (1 = sí, 0 = no)
* 12.	**IsActiveMember:** si el cliente es un miembro activo (1 = sí, 0 = no)
* 14.	**Exited:** si el cliente se ha ido (1 = sí, 0 = no).


  * **NumOfProducts, HasCrCard, IsActiveMember y Exited** tienen distribuciones con picos definidos. Esto ocurre porque son variables categóricas representadas como números (por ejemplo, 0 y 1 para si/no).

* **Tenure** (Tiempo como cliente)
  * Parece estar distribuido de manera relativamente uniforme, con algunos valores más frecuentes que otros.

#**Matriz de gráficos de dispersión (pairplot)**(sns.pairplot)

Este código genera una matriz de gráficos de dispersión (pairplot) para analizar la relación entre las **variables numéricas** del dataset df_Seg_Clientes. Para el análisis se usaran solo algunas **variables clave:** En lugar de mostrar todas las combinaciones ya que su lectura era difil con todas las variables numéricas.

Se realizara visualizacion con las siguientes variables:

- **Exited** → Si el cliente se fue del banco (1 = sí, 0 = no).

- **Age** → Edad del cliente.

- **Balance** → Saldo en la cuenta del cliente.

- **CreditScore** → Puntuación crediticia del cliente.

- **NumOfProducts** → Número de productos bancarios que usa el cliente.

A continuación se genera este gráfico que es un pairplot generado con la biblioteca Seaborn en Python. Un pairplot nos permite visualizar relaciones entre múltiples variables en un dataset a través de diagramas de dispersión y distribuciones.

**1. ¿Qué muestra el gráfico?**
- **Cada celda representa una relación entre dos variables.**

  - En la diagonal principal (de arriba a la izquierda a abajo a la derecha), se muestran las distribuciones de cada variable.

  - En las otras celdas, se muestran diagramas de dispersión (scatter plots) comparando dos variables diferentes.

- **Los colores representan la variable "Exited"**, que es la variable de salida (0 o 1), indicando si un cliente ha abandonado o no.(Naranja clientes que se han ido - Azul clientes que continúan en el banco)

**2. ¿Qué hace el código?**
- **Crea el pairplot con** sns.pairplot(), usando las variables seleccionadas de df_Seg_Clientes.

- **Usa hue="Exited"** para diferenciar con colores los clientes que se quedaron (Azul = 0) y los que se fueron (Naranja = 1).

- **Ajusta la transparencia** (alpha=0.5) para evitar sobrecarga visual.

- **Modifica el tamaño del gráfico** (fig.set_size_inches(12, 10)) para que sea más legible.

- **Aumenta el espacio entre gráficos** (fig.subplots_adjust()) para evitar que se superpongan.

- **Agrega títulos en cada gráfico** para indicar qué variables se están comparando.
"""

#Importar Seaborn es una librería de visualización basada en matplotlib, útil para gráficos estadísticos.
# import seaborn as sns # lo dejo comentado ya que lo descargue al inicio del colab
#import matplotlib.pyplot as plt # lo dejo comentado ya que lo descargue al inicio del colab

# Creamos una lista con las variables que nos interesan analizar
variables_interes = ["Exited", "Age", "Balance", "CreditScore", "NumOfProducts"]

# Generamos un gráfico de pares (pairplot) para analizar la relación entre esas variables
# hue="Exited" colorea los puntos según si el cliente se fue (1 Naranja) o se quedó (0 Azul)
# plot_kws={"alpha":0.5} → Hace los puntos más transparentes para que no se amontonen.
pairplot = sns.pairplot(df_Seg_Clientes[variables_interes], hue="Exited", plot_kws={"alpha":0.5})

# Ajustar tamaño general del gráfico
pairplot.fig.set_size_inches(12, 10)  # Aumentar el tamaño general del gráfico

# Ajustar espaciado entre los gráficos para evitar solapamientos
pairplot.fig.subplots_adjust(hspace=0.7, wspace=0.5)  # Aumentar espacio entre filas (hspace) y columnas (wspace)

# Agregar títulos en cada gráfico
for i, ax in enumerate(pairplot.axes.flat):
    if ax is not None:  # Evita gráficas vacías por `corner=True`
        x_label = ax.get_xlabel()
        y_label = ax.get_ylabel()
        ax.set_title(f"X: {x_label}, Y: {y_label}", fontsize=8, pad=20)  # Ajustar el tamaño y la posición del título

plt.show()

"""#**Análisis gráficos de dispersión**

**1. "X: Y: Age" (Gráfico en la diagonal)**
- Este gráfico muestra la distribución de la edad de los clientes.
- La mayoría de los clientes tienen entre 25 y 40 años.
- Hay menos clientes mayores de 50 años.

Los clientes que han salido (en naranja) parecen estar más presentes en el grupo de edad avanzada.

**2. "X: Balance, Y: Age"**
- Este gráfico compara el saldo en la cuenta bancaria (Balance) con la edad del cliente.
-No parece haber una relación clara entre la edad y el saldo.
- Los clientes que se fueron (naranja) están dispersos en diferentes edades y saldos.

**3. "X: CreditScore, Y: Age"**
- Aquí se comparan la puntuación de crédito (CreditScore) y la edad.
- Los clientes con puntuaciones de crédito más bajas y más altas están distribuidos de manera uniforme en todas las edades.
- No hay una clara separación entre los que se quedan y los que se van.

**4. "X: NumOfProducts, Y: Age"**
- Este gráfico muestra cuántos productos tiene un cliente en relación con su edad.
- Se observa que la mayoría de los clientes tienen entre 1 y 2 productos.
- Los clientes con 3 o más productos parecen ser menos comunes.
- Hay más clientes que se fueron (naranja) entre los que tienen 1 solo producto.

**5. "X: Age, Y: Balance"**
- Aquí se observa la relación entre la edad y el saldo en la cuenta bancaria.
- Parece haber una gran cantidad de clientes con saldo cercano a 0.
- Los clientes con saldo alto están distribuidos en todas las edades, sin un patrón claro de salida.

**6. "X: Y:" (Gráfico en la diagonal)**
- Este es otro gráfico de distribución (probablemente Balance).
- Muestra que muchos clientes tienen saldo cero o bajo en su cuenta.

**7. "X: CreditScore, Y: Balance"**
- Relaciona la puntuación de crédito con el saldo en la cuenta.
- No parece haber una relación clara entre la puntuación de crédito y el saldo.
- Los clientes que se fueron están mezclados con los que se quedaron.

**8. "X: NumOfProducts, Y: Balance"**
- Analiza la cantidad de productos bancarios en relación con el saldo en la cuenta.
- Los clientes con 1 o 2 productos tienen una amplia variedad de saldos.
- Pocos clientes con 3 o más productos tienen saldos elevados.
- Parece haber más clientes que se fueron entre los que tienen solo 1 producto.

**9. "X: Age, Y: CreditScore"**
- Muestra la relación entre la edad y la puntuación de crédito.
- No hay una correlación clara.
- La distribución de los clientes que se fueron es bastante uniforme.

**10. "X: Balance, Y: CreditScore"**
- Compara el saldo en la cuenta y la puntuación de crédito.
- No hay una relación clara entre ambas variables.
- Los clientes que se fueron y los que se quedaron están distribuidos de manera similar.

**11. "X: Y:" (Gráfico en la diagonal)**
- Este es otro gráfico de distribución (probablemente CreditScore).
- La mayoría de los clientes tienen una puntuación de crédito entre 600 y 800.

**12. "X: NumOfProducts, Y: CreditScore"**
- Relación entre la cantidad de productos y la puntuación de crédito.
- Los clientes con 1 o 2 productos tienen puntuaciones de crédito variadas.
- Parece que la mayoría de los clientes que se fueron tenían 1 producto.

**13. "X: Age, Y: NumOfProducts"**
- Relaciona la edad con la cantidad de productos bancarios.
- La mayoría de los clientes tienen 1 o 2 productos en todas las edades.
- Los clientes con más de 3 productos son muy pocos.

**14. "X: Balance, Y: NumOfProducts"**
- Analiza la relación entre saldo y cantidad de productos.
- No parece haber una relación clara entre ambas variables.
- Sin embargo, los clientes con 1 solo producto parecen ser los que más se fueron.

**15. "X: CreditScore, Y: NumOfProducts"**
- Muestra la relación entre la puntuación de crédito y la cantidad de productos.
- No hay una fuerte correlación entre ambas variables.
- La mayoría de los clientes tienen 1 o 2 productos sin importar su puntuación de crédito.

**16. "X: NumOfProducts, Y:" (Gráfico en la diagonal)**
- Muestra la distribución de la cantidad de productos.
- La mayoría de los clientes tienen 1 o 2 productos.
- Pocos tienen 3 o más productos.

**Conclusiones Generales**
- La edad parece influir en la salida de clientes (más clientes mayores han salido).
- Los clientes con 1 solo producto tienen más probabilidades de irse.
- El saldo en la cuenta y la puntuación de crédito no muestran una relación clara con la salida del cliente.
- No hay una fuerte correlación entre la cantidad de productos y otras variables, pero los que tienen más de 3 productos son pocos.

# **Mapa de Calor Correlacional**

Se genera Mapa de calor de las variables numéricas excluyendo las dos primeras filas (RowNumber y CustomerId no aparecerán en los histogramas) ya que para el estudio inicial no serían necesarias.
"""

# Correlación entre las variables

# Seleccionar solo las columnas numéricas y excluir las dos primeras
df_numericas = df_Seg_Clientes.select_dtypes(include=['int64', 'float64']).iloc[:, 2:]

# Crear el mapa de calor de correlaciones
plt.figure(figsize=(12, 8))
sns.heatmap(df_numericas.corr(), annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)

# Título del gráfico
plt.title('Mapa de Calor de Correlaciones')

# Mostrar el gráfico
plt.show()

"""**Explicación del Mapa de Calor de Correlaciones**

El gráfico generado es un mapa de calor de correlaciones, que muestra cómo se relacionan las variables numéricas entre sí dentro del conjunto de datos de clientes del banco.

**¿Qué representa el mapa de calor?**

* **Cada celda** en el gráfico muestra un **coeficiente de correlación** entre dos variables.

* Los valores de correlación van de **-1 a 1:**

  * **1.0 (rojo oscuro)** → Correlación perfecta y positiva (si una variable aumenta, la otra también).

  * **0.0 (azul claro)** → No hay correlación (las variables no tienen relación entre sí).

  * **-1.0 (azul oscuro)** → Correlación perfecta y negativa (si una variable aumenta, la otra disminuye).

La diagonal siempre tiene valores de **1.0**, ya que cualquier variable tiene correlación perfecta consigo misma.

**Análisis de las correlaciones importantes:**

**1. Edad y Exited (0.29)**

  * **Positiva y moderada:** A medida que la edad del cliente aumenta, es más probable que se vaya del banco.

**2. Balance y NumOfProducts (-0.30)**

  * **Negativa y moderada:** Los clientes con más productos bancarios tienden a tener saldos más bajos.

**3. IsActiveMember y Exited (-0.16)**

  * **Negativa y débil:** Los clientes que son miembros activos tienen menos probabilidad de irse del banco.

**4. Balance y Exited (0.12)**

  * **Positiva pero débil:** Los clientes con saldo más alto tienen una ligera tendencia a abandonar el banco.

**5. NumOfProducts y Exited (-0.05)**

  * **Negativa pero muy débil:** Los clientes con más productos bancarios tienden a quedarse, pero la relación es muy baja.

**Conclusión**

El mapa de calor ayuda a entender las relaciones entre las variables y a identificar patrones importantes en los datos. En este caso, podemos ver que:

* La edad influye en la salida del banco (los clientes mayores son más propensos a irse).

* Ser un miembro activo reduce la probabilidad de abandonar el banco.

* Los clientes con más productos bancarios suelen tener menos saldo.

*Al analizar los datos para mejorar la retención de clientes, quizás tendría que enfocarme en estrategias para **fidelizar a los clientes mayores y con saldo alto**, ya que son los que tienen más probabilidades de irse.*

# Detectar outliers o valor atípico
Para detectar outliers en el dataset df_Seg_Clientes se puede usar un boxplot para cada variable numérica o aplicar el método estadístico de los cuartiles (IQR - Rango Intercuartil).

**Método con Boxplot (Visualización)**

Graficare un boxplot para cada variable numérica y visualizar los valores atípicos.

Nota: Un outlier (o valor atípico) es un dato que se encuentra significativamente alejado del resto de los valores en un conjunto de datos. Es decir, son valores extremadamente altos o bajos que no siguen el mismo patrón que la mayoría de los datos, y se representan en el gráfico como los puntos que están fuera de los bigotes (líneas superiores/inferiores).
"""

#dejo comentado la importacion de librerias ya que lo hice al inicio del colab
#import seaborn as sns  # Seaborn es una biblioteca para visualización estadística
#import matplotlib.pyplot as plt  # Matplotlib es útil para crear gráficos básicos

# Definir las columnas numéricas a analizar
# Estas columnas contienen valores numéricos que queremos revisar para identificar outliers
numeric_features = ['CreditScore', 'Age', 'Balance', 'NumOfProducts', 'EstimatedSalary','Tenure']

# Crear una figura para los gráficos
# figsize especifica el tamaño total de la figura (ancho, alto en pulgadas)
plt.figure(figsize=(12, 6))

# Usamos un bucle para generar múltiples boxplots, uno para cada característica numérica
for i, feature in enumerate(numeric_features, 1):  # enumerate nos da el índice (i) y el nombre de la columna (feature)
    plt.subplot(2, 3, i)  # Crea una cuadrícula de gráficos: 2 filas, 3 columnas, el gráfico actual está en la posición i
    sns.boxplot(y=df_Seg_Clientes[feature])  # Crea el boxplot para la columna actual usando Seaborn
    plt.title(f'Boxplot de {feature}')  # Asigna un título al gráfico que incluye el nombre de la columna

# Ajustamos el diseño para evitar que los gráficos se solapen
plt.tight_layout()

# Mostrar los gráficos en pantalla
plt.show()

"""#**Explicación de los gráficos (Boxplots)**
Los boxplots o diagramas de caja ayudan a visualizar la distribución de una variable numérica y detectar outliers (valores atípicos).

A continuación haré un análisis de cada gráfico:

**1. Boxplot de CreditScore**
- Muestra la distribución de la puntuación de crédito.
- La mayoría de los valores están entre 600 y 800.
- Hay outliers en la parte baja (valores por debajo de 400).
- La mediana (línea dentro de la caja) está cerca de 700, lo que indica que la mitad de los clientes tienen un CreditScore superior a este valor.

**2. Boxplot de Age**
- Representa la distribución de la edad de los clientes.
- Se observa una gran cantidad de outliers en edades superiores a 60 años.
- La mayoría de los clientes tienen entre 25 y 45 años.
- La mediana está cerca de 40 años.

**3. Boxplot de Balance**
- Muestra el saldo bancario de los clientes.
- Se observa que hay clientes con saldo cero, lo cual es común en bancos (algunas personas no mantienen saldo).
- No se aprecian muchos outliers extremos.

**4. Boxplot de NumOfProducts**
- Representa el número de productos contratados por los clientes.
- La mayoría de los clientes tienen 1 o 2 productos.
- Hay outliers en el valor 4, lo que indica que pocos clientes tienen muchos productos.

**5. Boxplot de EstimatedSalary**
- Representa el salario estimado de los clientes.
- No tiene outliers, lo que sugiere una distribución uniforme de los salarios entre los clientes.
- Los valores están distribuidos entre 0 y 200,000.

**6. Boxplot de Tenure**
- Representa el número de años que un cliente ha estado con el banco.
- Se distribuye de manera uniforme entre 0 y 10 años.
- No hay outliers significativos.

**Conclusión**
- Se detectaron outliers en Age y CreditScore.
- La mayoría de los clientes tienen 1 o 2 productos.
- Muchos clientes tienen saldo cero.
- El salario está distribuido uniformemente.

#**Generación de un Reporte de Análisis Exploratorio (EDA) con ydata-profiling**

* Este código genera un reporte automático de análisis exploratorio de datos (EDA) a partir del dataset df_Seg.Clientes.csv
* La librería ydata-profiling, permite crear resúmenes detallados de los datos de forma rápida.

**1. Instalación de la librería ydata-profiling**
* El signo ! indica que se está ejecutando un comando en la terminal o consola de Jupyter Notebook.

* pip install ydata-profiling instala la librería necesaria para generar el informe.

**2. Importar la librería**

* Se importa ProfileReport, que es la clase principal que permite crear el informe de análisis exploratorio.

**3. Crear el reporte del dataset**

* **df_filtrado_Seg_clientes** Se eliminan las dos primeras columnas y se crea una copia del Dateframe que excluye las columnas RowNumber y CustomerId

* **ProfileReport**(df_filtrado_Seg_clientes, title="Reporte de Análisis Exploratorio de Datos", explorative=True)

* ***df_filtrado_Seg_clientes ***→ Es el DataFrame de pandas que queremos analizar.

* **title**="Reporte de Análisis Exploratorio de Datos" → Define el título del reporte.

* **explorative**=True → Activa un modo exploratorio que reduce el tiempo de procesamiento y ajusta algunas configuraciones para ser más eficiente.

**4. Mostrar el reporte en un notebook**

**to_notebook_iframe()** muestra el informe directamente dentro de un Jupyter o Colab, Notebook como un iframe interactivo.

**Si se quiere guardar el reporte como un archivo HTML, se puede usar:**

profile.to_file("reporte_Seg_Clientes.html")

* Esto guardará el reporte en el archivo "reporte_Seg_Clientes.html", que se puede abrir en un navegador.

**¿Qué información contiene este reporte?**

El ProfileReport genera un análisis detallado con las siguientes secciones:

✅ Resumen general: Número de variables, cantidad de datos faltantes, tipos de datos, etc.

✅ Estadísticas descriptivas: Media, mediana, desviación estándar, valores mínimos y máximos.

✅ Distribución de datos: Histogramas de cada variable.

✅ Correlaciones: Mapa de calor con las correlaciones entre variables.

✅ Valores atípicos (outliers): Detección de valores extremos en las columnas numéricas.

✅ Datos duplicados: Identificación de filas repetidas.
"""

# Instalar la libreria
#!pip install ydata-profiling

# Importar la librería
#from ydata_profiling import ProfileReport

# Eliminamos las dos primeras columnas del DataFrame (RowNumber y CustomerId)
# ya que no aportan información relevante para el análisis
# hara una copia del original llamado df_filtrado_Seg_clientes
df_filtrado_Seg_clientes = df_Seg_Clientes.iloc[:, 2:]

# Creamos el informe de análisis exploratorio con un título descriptivo
# Este informe analizará solo las columnas numéricas y categóricas del DataFrame filtrado
profile = ProfileReport(df_filtrado_Seg_clientes, title="Reporte de Análisis Exploratorio de Datos", explorative=True)

# Mostramos el informe dentro de Google Colab
# Esto permite ver el informe directamente sin necesidad de descargarlo
profile.to_notebook_iframe()

"""# Conclusiones EDA con ydata-profiling.

**Overview - Data statistics**
- Valores nulos 4: se puede eliminar en la parte de limpieza ya que representa el < 0.1% de los datos con lo que la muestra ya es suficiente sin trasformarlos.
- Valores duplicados 2: se tendrán que eliminar en la parte de limpieza.

**Variables**
Tras revisar los datos tendré que tener en cuenta en la limpieza y transformación la siguientes columnas:
- Surname: eliminar ya que no aporta valor a los datos.
- Geography:  convertir en variables.
- Gender: convertir en variable.
- NumOfProducts tiene solo 4 valores: Podría tratarse como variable categórica.
- Age: tiene outlier para mayores de 62 años, tendré que ver si los elimino o si tranformo los datos para poder entrenar el modelo.

**Correlaciones Altas**
- Edad vs. Exited (0.375) → Fuerte relación: A mayor edad, más probabilidades de que un cliente abandone el banco.
- NumOfProducts vs. Exited (0.387) → Correlación fuerte: Los clientes con más productos bancarios tienden a permanecer, mientras que los que tienen pocos podrían estar en riesgo de irse.
- Balance vs. Exited (0.141) → Relación moderada: Los clientes con ciertos niveles de balance pueden estar más propensos a abandonar.
- Geography vs. Balance (0.315) → Influencia geográfica en el saldo bancario. Puede haber diferencias entre países o regiones.
- IsActiveMember vs. Exited (0.156) → Clientes más activos tienen menor probabilidad de abandonar.

**Correlaciones Débiles**

CreditScore, EstimatedSalary, HasCrCard tienen correlaciones muy bajas con otras variables. Esto sugiere que no influyen demasiado en la permanencia del cliente.

Tenure (tiempo en el banco) casi no tiene relación con el abandono (Exited = 0.022). Esto indica que la antigüedad no es un factor clave para que los clientes se vayan.

**Conclusiones para el Análisis de Segmentación**

- Factores de riesgo de abandono: Edad alta, pocos productos contratados, balance específico, y baja actividad.
- Factores menos relevantes: Ingresos, puntaje crediticio, tarjetas de crédito.
- Geografía impacta el balance, por lo que podría ser útil en la segmentación.
"""